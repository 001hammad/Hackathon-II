# Data Model - Phase II Full-Stack Multi-User Web Todo Application

**Date**: 2026-01-02
**Feature**: 001-phase2-web-todo

## Overview

This document defines the data models, database schema, and entity relationships for the Phase II multi-user web todo application using Neon PostgreSQL and SQLModel ORM.

## Database: Neon Serverless PostgreSQL

**Connection**:
- Provider: Neon (https://neon.tech)
- Protocol: PostgreSQL 15+
- Connection Pooling: Enabled by default
- SSL Mode: Required

**Environment Variables**:
```bash
DATABASE_URL="postgresql://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb?sslmode=require"
DATABASE_URL_ASYNC="postgresql+asyncpg://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb?sslmode=require"
BETTER_AUTH_SECRET="your-secret-key-minimum-32-characters"
```

## Core Entities

### 1. User Entity

**Purpose**: Represents a registered user account with authentication credentials.

**Managed By**: Better Auth (authentication library)

**Fields**:
| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique user identifier (generated by Better Auth) |
| email | VARCHAR(255) | UNIQUE, NOT NULL | User's email address (login identifier) |
| password_hash | VARCHAR(255) | NOT NULL | Bcrypt hashed password (never store plaintext) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Indexes**:
- Primary Key: `id`
- Unique Index: `email`

**Relationships**:
- Has Many: `tasks` (one user owns many tasks)

**Validation Rules** (from FR-002, FR-003):
- Email must be valid format (RFC 5322)
- Email must be unique (enforced at database level)
- Password must be minimum 8 characters
- Password must contain at least: 1 uppercase, 1 lowercase, 1 number
- Password hashed with bcrypt before storage

**Notes**:
- Better Auth creates and manages this table automatically
- Backend only reads user_id from JWT; does not directly modify user table
- Password reset functionality deferred to future phase

---

### 2. Task Entity

**Purpose**: Represents a single todo item owned by a specific user.

**Managed By**: Custom application code (backend API)

**Fields**:
| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | INTEGER | PRIMARY KEY, AUTO INCREMENT | Unique task identifier |
| user_id | UUID | FOREIGN KEY (users.id), NOT NULL, INDEXED | Owner of the task |
| description | VARCHAR(500) | NOT NULL | Task description text |
| completed | BOOLEAN | NOT NULL, DEFAULT FALSE | Completion status |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Task creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Indexes**:
- Primary Key: `id`
- Foreign Key Index: `user_id` (optimizes user isolation queries)

**Relationships**:
- Belongs To: `user` (each task belongs to exactly one user)

**Validation Rules** (from FR-009 through FR-013):
- description: Required, non-empty, max 500 characters
- completed: Boolean (true/false)
- user_id: Must exist in users table (foreign key constraint)
- created_at, updated_at: Automatically set by database

**Business Rules**:
- Users can only access their own tasks (enforced by user_id filter)
- Tasks cannot be shared between users (no multi-user access)
- Deleting a task is permanent (no soft delete)
- User deletion should cascade delete all their tasks (ON DELETE CASCADE)

---

## SQLModel Schema Definitions

### User Model

```python
# backend/app/models/user.py
from datetime import datetime
from typing import Optional, List
from sqlmodel import Field, SQLModel, Relationship
from uuid import UUID, uuid4

class User(SQLModel, table=True):
    """
    User model managed by Better Auth.
    Backend reads user_id from JWT but does not directly modify this table.
    """
    __tablename__ = "users"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    email: str = Field(unique=True, index=True, max_length=255)
    password_hash: str = Field(max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationships
    tasks: List["Task"] = Relationship(back_populates="user", cascade_delete=True)

    class Config:
        arbitrary_types_allowed = True

    def __repr__(self):
        return f"<User(id={self.id}, email='{self.email}')>"
```

### Task Model

```python
# backend/app/models/task.py
from datetime import datetime
from typing import Optional
from sqlmodel import Field, SQLModel, Relationship
from uuid import UUID

class Task(SQLModel, table=True):
    """
    Task model for todo items.
    Each task belongs to exactly one user (enforced by user_id foreign key).
    """
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True, nullable=False)
    description: str = Field(max_length=500, nullable=False)
    completed: bool = Field(default=False, nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)
    updated_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)

    # Relationships
    user: Optional["User"] = Relationship(back_populates="tasks")

    class Config:
        arbitrary_types_allowed = True

    def __repr__(self):
        status = "✓" if self.completed else "○"
        return f"<Task(id={self.id}, description='{self.description[:30]}...', {status})>"

    def to_dict(self) -> dict:
        """Convert task to dictionary for API responses."""
        return {
            "id": self.id,
            "user_id": str(self.user_id),
            "description": self.description,
            "completed": self.completed,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
```

---

## Entity Relationship Diagram (ERD)

```
┌─────────────────────────┐
│        User             │
├─────────────────────────┤
│ id (UUID, PK)           │
│ email (UNIQUE)          │
│ password_hash           │
│ created_at              │
│ updated_at              │
└───────────┬─────────────┘
            │
            │ 1:N (one-to-many)
            │
┌───────────▼─────────────┐
│        Task             │
├─────────────────────────┤
│ id (INT, PK)            │
│ user_id (UUID, FK)      │◄─── Foreign Key to User.id
│ description             │
│ completed               │
│ created_at              │
│ updated_at              │
└─────────────────────────┘
```

**Key Relationships**:
- **One User → Many Tasks**: One user can have zero or more tasks
- **One Task → One User**: Each task belongs to exactly one user (enforced by foreign key)
- **Cascade Delete**: Deleting a user deletes all their tasks (ON DELETE CASCADE)

---

## Database Initialization

### Schema Creation

```python
# backend/app/database/init.py
from sqlmodel import SQLModel, create_engine
from app.models.user import User
from app.models.task import Task
import os

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL, echo=True)

def create_db_and_tables():
    """Create all tables if they don't exist."""
    SQLModel.metadata.create_all(engine)

def drop_db_and_tables():
    """Drop all tables (use with caution - for testing only)."""
    SQLModel.metadata.drop_all(engine)
```

### Migration Strategy

**Phase 2 (Initial Launch)**:
- Use SQLModel's `create_all()` to generate schema
- No migration tool required (simple schema)

**Future Phases**:
- If schema changes needed, use Alembic for migrations
- Deferred to future phase (not required for MVP)

---

## Data Access Patterns

### User Isolation (Critical Security Requirement)

**All task queries MUST filter by user_id**:

```python
# CORRECT: Filter by authenticated user_id
from sqlmodel import Session, select

def get_user_tasks(session: Session, user_id: UUID) -> List[Task]:
    """Get all tasks for the authenticated user."""
    statement = select(Task).where(Task.user_id == user_id)
    return session.exec(statement).all()

# INCORRECT: Never query all tasks without user filter
def get_all_tasks(session: Session) -> List[Task]:
    """SECURITY VIOLATION: Exposes all users' tasks!"""
    statement = select(Task)
    return session.exec(statement).all()  # ❌ BAD!
```

### Common Queries

**Get user's tasks**:
```python
statement = select(Task).where(Task.user_id == user_id)
tasks = session.exec(statement).all()
```

**Get specific task (with ownership check)**:
```python
statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)
task = session.exec(statement).first()
if not task:
    raise HTTPException(404, "Task not found or access denied")
```

**Create task**:
```python
task = Task(user_id=user_id, description=description, completed=False)
session.add(task)
session.commit()
session.refresh(task)
```

**Update task description**:
```python
statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)
task = session.exec(statement).first()
if not task:
    raise HTTPException(404, "Task not found or access denied")
task.description = new_description
task.updated_at = datetime.utcnow()
session.add(task)
session.commit()
```

**Toggle task completion**:
```python
statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)
task = session.exec(statement).first()
if not task:
    raise HTTPException(404, "Task not found or access denied")
task.completed = not task.completed
task.updated_at = datetime.utcnow()
session.add(task)
session.commit()
```

**Delete task**:
```python
statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)
task = session.exec(statement).first()
if not task:
    raise HTTPException(404, "Task not found or access denied")
session.delete(task)
session.commit()
```

---

## Validation Rules Summary

**From Specification FR-001 through FR-020**:

| Entity | Field | Rule | Source |
|--------|-------|------|--------|
| User | email | Valid format (RFC 5322) | FR-002 |
| User | email | Unique | FR-002 |
| User | password | Min 8 chars, 1 upper, 1 lower, 1 number | FR-003 |
| User | password_hash | Bcrypt hashed | FR-015 |
| Task | description | Required, non-empty | FR-009 |
| Task | description | Max 500 characters | Assumption (UI constraint) |
| Task | user_id | Must exist in users table | FR-008 |
| Task | completed | Boolean (true/false) | FR-011 |

---

## Performance Considerations

**Indexes**:
- `users.email`: Unique index for fast login lookups
- `tasks.user_id`: Index for fast user isolation queries
- `tasks.id`: Primary key index (automatic)

**Query Optimization**:
- Always filter by user_id first (uses index)
- Limit query results if pagination added later
- Use `session.exec().first()` for single-record queries

**Connection Pooling**:
- Neon provides built-in connection pooling
- No need for pgbouncer in Phase 2

---

## Testing Strategy

**Unit Tests**:
- Test model validation (email format, password requirements)
- Test relationship definitions (user.tasks, task.user)
- Test to_dict() serialization

**Integration Tests**:
- Test database connection
- Test CRUD operations with real database
- Test user isolation (ensure User A cannot access User B's tasks)
- Test cascade delete (deleting user deletes their tasks)

**Test Database**:
- Use separate Neon branch for testing (Neon feature)
- Or use SQLite for faster test execution
- Reset database between tests

---

## Summary

**Entities**: 2 (User, Task)
**Relationships**: 1 (User has many Tasks)
**Indexes**: 3 (users.id, users.email, tasks.user_id)
**Foreign Keys**: 1 (tasks.user_id → users.id)
**Validation Rules**: 7 (email format, uniqueness, password strength, description length, etc.)

**Critical Security Rule**: ALL task queries MUST filter by authenticated user_id to enforce user isolation (FR-008).
